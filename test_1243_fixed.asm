; THIS IS THE MODIFIED SEPTEMBER ATARI 400/800 COMPUTER OPERATING
; SYSTEM LISTING. MODIFIED TO ASSEMBLE ON THE MICROTEC CROSS
; ASSEMBLER.
; THIS VERSION IS THE ONE WHICH WAS BURNED INTO ROM.
; THERE IS A RESIDUAL PIECE OF CODE WHICH IS FOR LNBUG. THIS
; IS AT LOCATION $9000 WHICH IS NOT IN ROM.
;
; THIS IS THE REVISION B EPROM VERSION
		  .PAGE
;
;
;		 COLLEEN OPERATING SYSTEM EQUATE FILE
;
;		 NTSC/PAL ASSEMBLY FLAG
;
PALFLG  =		 0			  ;0 = NTSC	1 = PAL
;
;
;		 MODULE ORIGIN TABLE
;
CHRORG  =		 $E000		 ;CHARACTER SET
VECTBL  =		 $E400		 ;VECTOR TABLE
VCTABL  =		 $E480		 ;RAM VECTOR INITIAL VALUE TABLE
CIOORG  =		 $E4A6		 ;CENTRAL I/O HANDLER
INTORG  =		 $E6D5		 ;INTERRUPT HANDLER
SIOORG  =		 $E944		 ;SERIAL I/O DRIVER
DSKORG  =		 $EDEA		 ;DISK HANDLER
PRNORG  =		 $EE78		 ;PRINTER HANDLER
CASORG  =		 $EF41		 ;CASSETTE HANDLER
MONORG  =		 $F0E3		 ;MONITOR/POWER UP MODULE
KBDORG  =		 $F3E4		 ;KEYBOARD/DISPLAY HANDLER
;
;
;
;
;		VECTOR TABLE
;
;HANDLER ENTRY POINTS ARE CALLED OUT IN THE FOLLOWING VECTOR
;TABLE. THESE ARE THE ADDRESSES MINUS ONE.
;
;
;EXAMPLE FOR EDITOR
;
;	 E400		 OPEN
;		 2		 CLOSE
;		 4		 GET
;		 6		 PUT
;		 8		 STATUS
;		 A		 SPECIAL
;		 C		 JUMP TO POWER ON INITIALIZATION ROUTINE
;		 F		 NOT USED
;
;
EDITRV  =		 $E400		 ;EDITOR
SCRENV  =		 $E410		 ;TELEVISION SCREEN
KEYBDV  =		 $E420		 ;KEYBOARD
PRINTV  =		 $E430		 ;PRINTER
CASETV  =		 $E440		 ;CASSETTE
;
;		 JUMP VECTOR TABLE
;
;THE FOLLOWING IS A TABLE OF JUMP INSTRUCTIONS
;TO VARIOUS ENTRY POINTS IN THE OPERATING SYSTEM.
;
DISKIW  =		 $E450		 ;DISK INITIALIZATION
DSKINV  =		 $E453		 ;DISK INTERFACE
CIOV	 =		 $E456		 ;CENTRAL INPUT OUTPUT ROUTINE
SIOV	 =		 $E459		 ;SERIAL INPUT OUTPUT ROUTINE
SETVBV  =		 $E45C		 ;SET SYSTEM TIMERS ROUTINE
SYSVBV  =		 $E45F		 ;SYSTEM VERTICAL BLANK CALCULATIONS
XITVBV  =		 $E462		 ;EXIT VERTICAL BLANK CALCULATIONS
SIOINV  =		 $E465		 ;SERIAL, INPUT OUTPUT INITIALIZATION
SENDEV  =		 $E468		 ;SEND ENABLE ROUTINE
INTINV  =		 $E46B		 ;INTERRUPT HANDLER INITIALIZATION
CIOINV  =		 $E46E		 ;CENTRAL INPUT OUTPUT INITIALIZATION
BLKBDV  =		 $E471		 ;BLACKBOARD MODE
WARMSV  =		 $E474		 ;WARM START ENTRY POINT
COLDSV  =		 $E477		 ;COLD START ENTRY POINT
RBLOKV  =		 $E47A		 ;CASSETTE READ BLOCK ENTRY POINT VECTOR
CSOPIV  =		 $E47D		 ;CASSETTE OPEN FOR INPUT VECTOR
;VCTABL = $E480
;
;
; OPERATING SYSTEM EQUATES
;
; COMMAND CODES FOR IOCB
OPEN	 =		 3			  ;OPEN FOR INPUT/OUTPUT
GETREC  =		 5			  ;GET RECORD (TEXT)
GETCHR  =		 7			  ;GET CHARACTER(S)
PUTREC  =		 9			  ;PUT RECORD (TEXT)
PUTCHR  =		 $B			 ;PUT CHARACTER(S)
CLOSE	=		 $C			 ;CLOSE DEVICE
STATIS  =		 $D			 ;STATUS REQUEST
SPECIL  =		 $E			 ;BEGINNING OF SPECIAL ENTRY COMMANDS
;
; SPECIAL ENTRY COMMANDS
DRAWLN  =		 $11			;DRAW LINE
FILLIN  =		 $12			;DRAW LINE WITH RIGHT FILL
RENAME  =		 $20			;RENAME DISK FILE
DELETE  =		 $21			;DELETE DISK FILE
FORMAT  =		 $22			;FORMAT
LOCKFL  =		 $23			;LOCK FILE TO READ ONLY
UNLOCK  =		 $24			;UNLOCK LOCKED FILE
POINT	=		 $25			;POINT SECTOR
NOTE	 =		 $26			;NOTE SECTOR
IOCFRE  =		 $FF			;IOCB "FREE"
;
; AUX1 EQUATES
; () INDICATES WHICH DEVICES USE BIT
APPEND  =		 $1			 ;OPEN FOR WRITE APPEND (D), OR SCREEN READ (
DIRECT  =		 $2			 ;OPEN FOR DIRECTORY ACCESS (D)
OPNIN	=		 $4			 ;OPEN FOR INPUT (ALL DEVICES)
OPNOT	=		 $8			 ;OPEN FOR OUTPUT (ALL DEVICES)
OPNINO  =		 OPNIN+OPNOT ;OPEN FOR INPUT AND OUTPUT (ALL DEVICES)
MXDMOD  =		 $10			;OPEN FOR MIXED MODE (E,S)
INSCLR  =		 $20			;OPEN WITHOUT CLEARING SCREEN (E,S)
;
; DEVICE NAMES
SCREDT  =		 'E			 ;SCREEN EDITOR (R/W)
KBD	  	=		 'K			 ;KEYBOARD (R ONLY)
D1SPLY  =		 'S			 ;SCREEN DISPLAY (R/W)
PRINTR  =		 'P			 ;PRINTER (W ONLY)
CASSET  =		 'C			 ;CASSETTE
MODEM	=		 'M			 ;MODEM
DISK	 =		 'D			 ;DISK (R/W)
;
; SYSTEM EOL (CARRIAGE RETURN)
CR		=		 $9B
;
;
;		 OPERATING SYSTEM STATUS CODES
;
SUCCES  =		 $01			;SUCCESSFUL OPERATION
;
BRKABT  =		 $80			;BREAK KEY ABORT
PRVOPN  =		 $81			;IOCB ALREADY OPEN
NONDEV  =		 $82			;NON-EXISTANT DEVICE
WRONLY  =		 $83			;IOCB OPENED FOR WRITE ONLY
NVALID  =		 $84			;INVALID COMMAND
NOTOPN  =		 $85			;DEVICE OR FILE NOT OPEN
BADIOC  =		 $86			;INVALID IOCB NUMBER
RDONLY  =		 $87			;IOCB OPENED FOR READ ONLY
EOFERR  =		 $88			;END OF FILE
TRNRCD  =		 $89			;TRUNCATED RECORD
TIMOUT  =		 $8A			;PERIPHERAL DEVICE TIME OUT
DNACK	=		 $8B			;DEVICE DOES NOT ACKNOWLEDGE COMMAND
FRMERR  =		 $8C			;SERIAL BUS FRAMING ERROR
CRSROR  =		 $8D			;CURSOR OVERRANCE
OVRRUN  =		 $8E			;SERIAL BUS DATA OVERRUN
CHKERR  =		 $8F			;SERIAL BUS CHECKSUM ERROR
;
DERROR  =		 $90			;PERIPHERAL DEVICE ERROR (OPERATION NOT COMP
BADMOD  =		 $91			;BAD SCREEN MODE NUMBER
FNCNOT  =		 $92			;FUNCTION NOT IMPLEMENTED IN HANDLER
SCRMEM  =		 $93			;INSUFICIENT MEMORY FOR SCREEN MODE
;
;
;
;
;
;
;		 PAGE ZERO RAM ASSIGNMENTS
;
		  *=$0000
LINZBS: .RES	 2			  ;LINBUG RAM (WILL BE REPLACED BY MONITOR RAM
;
; THESE LOCATIONS ARE NOT CLEARED
CASINI: .RES	 2			  ;CASSETTE INIT LOCATION
RAMLO:  .RES	 2			  ;RAM POINTER FOR MEMORY TEST
TRAMSZ: .RES	 1			  ;TEMPORARY REGISTER FOR RAM SIZE
TSTDAT: .RES	 1			  ;RAM TEST DATA REGISTER
;
; CLEARED ON COLOSTART ONLY
WARMST: .RES	 1			  ;WARM START FLAG
BOOT?:  .RES	 1			  ;SUCCESSFUL BOOT FLAG
DOSVEC: .RES	 2			  ;DISK SOFTWARE START VECTOR
DOSINI: .RES	 2			  ;DISK SOFTWARE INIT ADDRESS
APPMHI: .RES	 2			  ;APPLICATIONS MEMORY HI LIMIT
;
; CLEARED ON COLD OR WARM START
INTZBS  =*						;INTERRUPT HANDLER
POKMSK: .RES	 1			  ;SYSTEM MASK FOR POKEY IRQ ENABLE
BRKKEY: .RES	 1			  ;BREAK KEY FLAG
RTCLOK: .RES	 3			  ;REAL TIME CLOCK (IN 16 MSEC UNITS)
;
BUFADR: .RES	 2			  ;INDIRECT BUFFER ADDRESS REGISTER
;
ICCOMT: .RES	 1			  ;COMMAND FOR VECTOR
;
DSKFMS: .RES	 2			  ;DISK FILE MANAGER POINTER
DSKUTL: .RES	 2			  ;DISK UTILITIES POINTER
;
PTIMOT: .RES	 1			  ;PRINTER TIME OUT REGISTER
PBPNT:  .RES	 1			  ;PRINT BUFFER POINTER
PBUFSZ: .RES	 1			  ;PRINT BUFFER SIZE
PTEMP:  .RES	 1			  ;TEMPORARY REGISTER
;
ZIOCB	=*						;ZERO PAGE I/O CONTROL BLOCK
IOCBSZ  =		 16			 ;NUMBER OF BYTES PER IOCB
MAXIOC  =		 8*IOCBSZ	 ;LENGTH OF THE IOCB AREA
IOCBAS  =*
ICHIDZ: .RES	 1			  ;HANDLER INDEX NUMBER (FF = IOCB FREE)
ICDNOZ: .RES	 1			  ;DEVICE NUMBER (DRIVE NUMBER)
ICCOMZ: .RES	 1			  ;COMMAND CODE
ICSTAZ: .RES	 1			  ;STATUS OF LAST IOCB ACTION
ICBALZ: .RES	 1			  ;BUFFER ADDRESS LOW BYTE
ICBAHZ: .RES	 1
ICPTLZ: .RES	 1			  ;PUT BYTE ROUTINE ADDRESS - 1
ICPTHZ: .RES	 1
ICBLLZ: .RES	 1			  ;BUFFER LENGTH LOW BYTE
ICBLHZ: .RES	 1
ICAX1Z: .RES	 1			  ;AUXILIARY INFORMATION FIRST BYTE
ICAX2Z: .RES	 1
ICSPRZ: .RES	 4			  ;TWO SPARE BYTES (CIO LOCAL USE)
ICIDNO  =		 ICSPRZ+2	 ;IOCB NUMBER X 16
CIOCHR  =		 ICSPRZ+3	 ;CHARACTER BYTE FOR CURRENT OPERATION
;
STATUS: .RES	 1			  ;INTERNAL STATUS STORAGE
CHKSUM: .RES	 1			  ;CHECKSUM (SINGLE BYTE SUM WITH CARRY)
BUFRLO: .RES	 1			  ;POINTER TO DATA BUFFER (LO BYTE)
BUFRHI: .RES	 1			  ;POINTER TO DATA BUFFER (HI BYTE)
BFENLO: .RES	 1			  ;NEXT BYTE PAST END OF THE DATA BUFFER (LO B
BFENHI: .RES	 1			  ;NEXT BYTE PAST END OF THE DATA BUFFER (HI B
CRETRY: .RES	 1			  ;NUMBER OF COMMAND FRAME RETRIES
DRETRY: .RES	 1			  ;NUMBER OF DEVICE RETRIES
BUFRFL: .RES	 1			  ;DATA BUFFER FULL FLAG
RECVDN: .RES	 1			  ;RECEIVE DONE FLAG
XMTDON: .RES	 1			  ;TRANSMISSION DONE FLAG
CHKSNT: .RES	 1			  ;CHECKSUM SENT FLAG
NOCKSM: .RES	 1			  ;NO CHECKSUM FOLLOWS DATA FLAG
;
;
BPTR:	.RES	 1
FTYPE:  .RES	 1
FEOF:	.RES	 1
FREQ:	.RES	 1
SOUNDR: .RES	 1			  ;NOISY I/O FLAG. (ZERO IS QUIET)
CRITIC: .RES	 1			  ;DEFINES CRITICAL SECTION (CRITICAL IF NON-Z
;
FMSZPG: .RES	 7			  ;DISK FILE MANAGER SYSTEM ZERO PAGE
;
;
CKEY:	.RES	 1			  ;FLAG SET WHEN GAME START PRESSED
CASSBT: .RES	 1			  ;CASSETTE BOOT FLAG
DSTAT:  .RES	 1			  ;DISPLAY STATUS
;
ATRACT: .RES	 1			  ;ATRACT FLAG
DRKMSK: .RES	 1			  ;DARK ATRACT MASK
COLRSH: .RES	 1			  ;ATRACT COLOR SHIFTER (EOR'ED WITH PLAYFIELD
;
LEDGE	=		 2			  ;LMARGN'S VALUE AT COLD START
REDGE	=		 39			 ;RMARGN'S VALUE AT COLD START
TMPCHR: .RES	 1
HOLD1:  .RES	 1
LMARGN: .RES	 1			  ;LEFT MARGIN (SET TO 1 AT POWER ON)
RMARGN: .RES	 1			  ;RIGHT MARGIN (SET TO 38 AT POWER ON)
ROWCRS: .RES	 1			  ;CURSOR COUNTERS
COLCRS: .RES	 2
DINDEX: .RES	 1
SAVMSC: .RES	 2
OLDROW: .RES	 1
OLDCOL: .RES	 2
OLDCHR: .RES	 1			  ;DATA UNDER CURSOR
OLDADR: .RES	 2
NEWROW: .RES	 1			  ;POINT DRAW GOES TO
NEWCOL: .RES	 2
LOGCOL: .RES	 1			  ;POINTS AT COLUMN IN LOGICAL LINE
ADRESS: .RES	 2
MLTTMP: .RES	 2
OPNTMP  =		 MLTTMP		;FIRST BYTE IS USED IN OPEN AS TEMP
SAVADR: .RES	 2
RAMTOP: .RES	 1			  ;RAM SIZE DEFINED BY POWER ON LOGIC
BUFCNT: .RES	 1			  ;BUFFER COUNT
BUFSTR: .RES	 2			  ;EDITOR GETCH POINTER
BITMSK: .RES	 1			  ;BIT MASK
SHFAMT: .RES	 1
ROWAC:  .RES	 2
COLAC:  .RES	 2
ENDPT:  .RES	 2
DELTAR: .RES	 1
DELTAC: .RES	 2
ROWINC: .RES	 1
COLINC: .RES	 1
SWPFLG: .RES	 1			  ;NON-0 IF TXT AND REGULAR RAM IS SWAPPED
HOLDCH: .RES	 1			  ;CH IS MOVED HERE IN KGETCH BEFORE CNTL & SH
INSDAT: .RES	 1
COUNTR: .RES	 2
;
;
;
;
;		 30 - FF ARE RESERVED FOR USER APPLICATIONS
;
;
;
;		 NOTE : SEE FLOATING POINT SUBROUTINE AREA FOR ZERO PAGE CELLS
;
;
;
;
;		 PAGE 1	-	 STACK
;
;
;
;
;		 PAGE TWO RAM ASSIGNMENTS
;
		  *=$0200
INTABS  =*						;INTERRUPT RAM
VDSLST: .RES	 2			  ;DISPLAY LIST NMI VECTOR
VPRCED: .RES	 2			  ;PROCEED LINE IRQ VECTOR
VINTER: .RES	 2			  ;INTERRUPT LINE IRQ VECTOR
VBREAK: .RES	 2			  ;SOFTWARE BREAK (00) INSTRUCTION IRQ VECTOR
VKEYBD: .RES	 2			  ;POKEY KEYBOARD IRQ VECTOR
VSERIN: .RES	 2			  ;POKEY SERIAL INPUT READY IRQ
VSEROR: .RES	 2			  ;POKEY SERIAL OUTPUT READY IRQ
VSEROC: .RES	 2			  ;POKEY SERIAL OUTPUT COMPLETE IRQ
VTIMR1: .RES	 2			  ;POKEY TIMER 1 IRQ
VTIMR2: .RES	 2			  ;POKEY TIMER 2 IRQ
VTIMR4: .RES	 2			  ;POKEY TIMER 4 IRQ
VIMIRU: .RES	 2			  ;IMMEDIATE IRQ VECTOR
CDTMV1: .RES	 2			  ;COUNT DOWN TIMER 1
CDTMV2: .RES	 2			  ;COUNT DOWN TIMER 2
CDTMV3: .RES	 2			  ;COUNT DOWN TIMER 3
CDTMV4: .RES	 2			  ;COUNT DOWN TIMER 4
CDTMV5: .RES	 2			  ;COUNT DOWN TIMER S
VVBLKI: .RES	 2			  ;IMMEDIATE VERTICAL BLANK NMI VECTOR
VVBLKD: .RES	 2			  ;DEFERRED VERTICAL BLANK NMI VECTOR
CDTMA1: .RES	 2			  ;COUNT DOWN TIMER 1 JSR ADDRESS
CDTMA2: .RES	 2			  ;COUNT DOWN TIMER 2 JSR ADDRESS
CDTMF3: .RES	 1			  ;COUNT DOWN TIMER 3 FLAG
SRTIMR: .RES	 1			  ;SOFTWARE REPEAT TIMER
CDTMF4: .RES	 1			  ;COUNT DOWN TIMER 4 FLAG
INTEMP: .RES	 1			  ;IAN'S TEMP (RENAMED FROM T1 BY POPULAR DEMA
CDTMF5: .RES	 1			  ;COUNT DOWN TIMER FLAG 5
SDMCTL: .RES	 1			  ;SAVE DMACTL REGISTER
SDLSTL: .RES	 1			  ;SAVE DISPLAY LIST LOW BYTE
SDLSTH: .RES	 1			  ;SAVE DISPLAY LIST HI BYTE
SSKCTL: .RES	 1			  ;SKCTL REGISTER RAM
		  .RES	 1
;
LPENH:  .RES	 1			  ;LIGHT PEN HORIZONTAL VALUE
LPENV:  .RES	 1			  ;LIGHT PEN VERTICAL VALUE
BRKKY:  .RES	 2			  ;BREAK KEY VECTOR
;
		  .RES	 2			  ;SPARE
;
CDEVIC: .RES	 1			  ;COMMAND FRAME BUFFER - DEVICE
CCOMND: .RES	 1			  ;COMMAND
CAUX1:  .RES	 1			  ;COMMAND AUX BYTE 1
CAUX2:  .RES	 1			  ;COMMANDAUX BYTE 2
;	NOTE: MAY NOT BE THE LAST WORD ON A PAGE
TEMP:	.RES	 1			  ;TEMPORARY RAM CELL
;	NOTE: MAY NOT BE THE LAST WORD ON A PAGE
ERRFLG: .RES	 1			  ;ERROR FLAG - ANY DEVICE ERROR EXCEPT TIME
;
DFLAGS: .RES	 1			  ;DISK FLAGS FROM SECTOR ONE
DBSECT: .RES	 1			  ;NUMBER OF DISK BOOT SECTORS
BOOTAD: .RES	 2			  ;ADDRESS WHERE DISK BOOT LOADERWILL BE PUT
COLDST: .RES	 1			  ;COLDSTART FLAG (1=IN MIDDLE OF COLDSTART)
;
		  .RES	 1			  ;SPARE
;
DSKTIM: .RES	 1			  ;DISK TIME OUT REGISTER
;
LINBUF: .RES	 40			 ;CHAR LINE BUFFER
;
GPRIOR: .RES	 1			  ;GLOBAL PRIORITY CELL
;
PADDL0: .RES	 1			  ;POTENTIOMETER 0 RAM CELL
PADDL1: .RES	 1
PADDL2: .RES	 1
PAODL3: .RES	 1
PADDL4: .RES	 1
PADDL5: .RES	 1
PADDL6: .RES	 1
PADDL7: .RES	 1
STICK0: .RES	 1			  ;JOYSTICK 0 RAM CELL
STICK1: .RES	 1
STICK2: .RES	 1
STICK3: .RES	 1
PTRIG0: .RES	 1			  ;PADDLE TRIGGER 0
PTRIG1: .RES	 1
PTRIG2: .RES	 1
PTRIG3: .RES	 1
PTRIG4: .RES	 1
PTRIG5: .RES	 1
PTRIG6: .RES	 1
PTRIG7: .RES	 1
STRIG0: .RES	 1			  ;JOYSTICK TRIGGER 0
STRIG1: .RES	 1
STRIG2: .RES	 1
STRIG3: .RES	 1
;
CSTAT:  .RES	 1
WMODE:  .RES	 1
BLIM:	.RES	 1
IMASK:  .RES	 1
JVECK:  .RES	 2
;
		  .RES	 2			  ;SPARE
;
;
;
;
TXTROW: .RES	 1			  ;TEXT ROWCRS
TXTCOL: .RES	 2			  ;TEXT COLCRS
TINDEX: .RES	 1			  ;TEXT INDEX
TXTMSC: .RES	 2			  ;FOOLS CONVRT INTO NEW MSC
TXTOLD: .RES	 6			  ;OLDROW & OLDCOL FOR TEXT (AND THEN SOME)
TMPX1:  .RES	 1
HOLD3:  .RES	 1
SUBTMP: .RES	 1
HOLD2:  .RES	 1
DMASK:  .RES	 1
TMPLBT: .RES	 1
ESCFLG: .RES	 1			  ;ESCAPE FLAG
TABMAP: .RES	 15
LOGMAP: .RES	 4			  ;LOGICAL LINE START BIT MAP
INVFLG: .RES	 1			  ;INVERSE VIDEO FLAG (TOGGLED BY ATARI KEY)
FILFLG: .RES	 1			  ;RIGHT FILL FLAG FOR DRAW
TMPROW: .RES	 1
TMPCOL: .RES	 2
SCRFLG: .RES	 1			  ;SET IF SCROLL OCCURS
HOLD4:  .RES	 1			  ;TEMP CELL USED IN DRAW ONLY
HOLD5:  .RES	 1			  ;DITTO
SHFLOK: .RES	 1
BOTSCR: .RES	 1			  ;BOTTOM OF SCREEN : 24 NORM 4 SPLIT
;
;
PCOLR0: .RES	 1			  ;P0 COLOR
PCOLR1: .RES	 1			  ;P1 COLOR
PCOLR2: .RES	 1			  ;P2 COLOR
PCOLP3: .RES	 1			  ;P3 COLOR
COLOR0: .RES	 1			  ;COLOR 0
COLOR1: .RES	 1
CQLOR2: .RES	 1
COLOR3: .RES	 1
COLOR4: .RES	 1
;
;
		  .RES	 23			 ;SPARE
;
;
;
GLBABS  =*						;GLOBAL VARIABLES
;
		  .RES	 4			  ;SPARE
;
RAMSIZ: .RES	 1			  ;RAM SIZE (HI BYTE ONLY)
MEMTOP: .RES	 2			  ;TOP OF AVAILABLE USER MEMORY
MEMLO:  .RES	 2			  ;BOTTOM OF AVAILABLE USER MEMORY
		  .RES	 1			  ;SPARE
DVSTAT: .RES	 4			  ;STATUS BUFFER
CBAUDL: .RES	 1			  ;CASSETTE BAUD RATE LOW BYTE
CBAUDH: .RES	 1
;
CRSINH: .RES	 1			  ;CURSOR INHIBIT (00 = CURSOR ON)
KEYDEL: .RES	 1			  ;KEY DELAY
CH1:	 .RES	 1
;
CHACT:  .RES	 1			  ;CHACTL REGISTER RAM
CHBAS:  .RES	 1			  ;CHBAS REGISTER RAM
;
		  .RES	 5			  ;SPARE BYTES
;
CHAR:	.RES	 1
ATACHR: .RES	 1			  ;ATASCII CHARACTER
CH:	  .RES	 1			  ;GLOBAL VARIABLE FOR KEYBOARD
FILDAT: .RES	 1			  ;RIGHT FILL DATA (DRAW)
DSPFLG: .RES	 1			  ;DISPLAY FLAG : DISPLAY CNTLS IF NON-ZERO
SSFLAG: .RES	 1			  ;START/STOP FLAG FOR PAGING (CNTL 1). CLEARE
;
;
;
;
;
;
;
;		 PAGE THREE RAM ASSIGNMENTS
;
DCB	  =*			 ;DEVICE CONTROL BLOCK
DDEVIC: .RES	 1			  ;PERIPHERAL UNIT 1 BUS ID. NUMBER
DUNIT:  .RES	 1			  ;UNIT NUMBER
DCOMND: .RES	 1			  ;BUS COMMAND
DSTATS: .RES	 1			  ;COMMAND TYPE/STATUS RETURN
DBUFLO: .RES	 1			  ;DATA BUFFER POINTER LOW BYTE
DBUFHI: .RES	 1
DTIMLO: .RES	 1			  ;DEVICE TIME OUT IN 1 SECOND UNITS
DUNUSE: .RES	 1			  ;UNUSED BYTE
DBYTLO: .RES	 1			  ;NUMBER OF BYTES TO BE TRANSFERRED LOW BYTE
DBYTHI: .RES	 1
DAUX1:  .RES	 1			  ;COMMAND AUXILIARY BYTE 1
DAUX2:  .RES	 1
;
TIMER1: .RES	 2			  ;INITIAL TIMER VALUE
ADDCOR: .RES	 1			  ;ADDITION CORRECTION
CASFLG: .RES	 1			  ;CASSETTE MODE WHEN SET
TIMER2: .RES	 2			  ;FINAL TIMER VALUE. THESE TWO TIMER VALUES
; ARE USED TO COMPUTE INTERVAL FOR BAUD RATE
TEMP1:  .RES	 2			  ;TEMPORARY STORAGE REGISTER
TEMP2:  .RES	 1			  ;TEMPORARY STORAGE REGISTER
TEMP3:  .RES	 1			  ;TEMPORARY STORAGE REGISTER
SAVIO:  .RES	 1			  ;SAVE SERIAL IN DATA PORT
TIMFLG: .RES	 1			  ;TIME OUT FLAG FOR BAUD RATE CORRECTION
STACKP: .RES	 1			  ;SIO STACK POINTER SAVE CELL
TSTAT:  .RES	 1			  ;TEMPORARY STATUS HOLDER
;
;
;
HATABS: .RES	 38			 ;HANDLER ADDRESS TABLE
MAXDEV  =		 *-HATABS-5  ;MAXIMUM HANDLER ADDRESS INDEX
;
;	  NOTE : THE ENTIRE IOCB DEFINITIONS HAVE BEEN MODIFIED
;
IOCB:	.ORG	 *			  ;I/O CONTROL BLOCKS
ICHID:  .RES	 1			  ;HANDLER INDEX NUMBER (FF = IOCB FREE)
ICDNO:  .RES	 1			  ;DEVICE NUMBER (DRIVE NUMBER)
ICCOM:  .RES	 1			  ;COMMAND CODE
ICSTA:  .RES	 1			  ;STATUS OF LAST IOCB ACTION
ICBAL:  .RES	 1			  ;BUFFER ADDRESS LOW BYTE
ICBAH:  .RES	 1
ICPTL:  .RES	 1			  ;PUT BYTE ROUTINE ADDRESS - 1
ICPTH:  .RES	 1
ICBLL:  .RES	 1			  ;BUFFER LENGTH LOW BYTE
ICBLH:  .RES	 1
ICAX1:  .RES	 1			  ;AUXILIARY INFORMATION FIRST BYTE
ICAX2:  .RES	 1
ICSPR:  .RES	 4			  ;FOUR SPARE BYTES
		  .RES	 MAXIOC-IOCBSZ
;
PRNBUF: .RES	 40			 ;PRINTER BUFFER
;
		  .RES	 21			 ;SPARE BYTES
;
;
;
;
;
;
;
;		 PAGE FOUR RAM ASSIGNMENTS
;
CASBUF: .RES	 131			;CASSETTE BUFFER
;
; USER AREA STARTS HERE AND GOES TO END OF PAGE FIVE
USAREA: .RES	 128			;SPARE
;
;
;
;
;
;
;
;		 PAGE FIVE RAM ASSIGNMENTS
;
;		 PAGE FIVE IS RESERVED AS A USER WORK SPACE
;
;		 NOTE:	SEE FLOATING POINT SUBROUTINE AREA FOR PAGE FIVE CELLS
;
;
;		 PAGE SIX RAM ASSIGNMENTS
;
; PAGE SIX IS RESERVED AS A USER'S USER WORK SPACE
;
;
;
;
;		 FLOATING POINT SUBROUTINES
;
FPREC	=		 6			  ;FLOATING PT PRECISION (# OF BYTES)
; IF CARRY USED THEN CARRY CLEAR => NO ERROR, CARR
AFP	  =		 $D800		 ;ASCII->FLOATING POINT(FP)
;										 INBUFF+CIX -> FR0, CIX, CARRY
FASC	 =		 $D8E6		 ;FP -> ASCII FR0 -> LBUFF (INBUFF)
IFP	  =		 $D9AA		 ;INTEGER -> FP
;										 0-$FFFF (LSB,MSB) IN FR0,FR0+1->FR0
FPI	  =		 $D9D2		 ;FP -> INTEGER FR0 -> FR0,FR0+1, CARRY
FSUB	 =		 $DA60		 ;FR0 <- FR0 - FR1 ,CARRY
FADD	 =		 $DA66		 ;FR0 <- FR0 + FR1 ,CARRY
FMUL	 =		 $DADB		 ;FR0 <- FR0 * FR1 ,CARRY
FDIV	 =		 $DB28		 ;FR0 <- FR0 / FR1 ,CARRY
FLD0R	=		 $DD89		 ;FLOATING LOAD REG0	FR0  <- (X,Y)
FLD0P	=		 $DD80		 ;	"		"	 "	  FR0  <- (FLFTR)
FLD1R	=		 $DD98		 ;	"		"	REG1	FR1  <- (X,Y)
FLD1P	=		 $DD9C		 ;	"		"	 "	  FR1  <- (FLPTR)
FSTOR	=		 $DDA7		 ;FLOATING STORE REG0 (X,Y) <- FR0
FSTOP	=		 $DDAB		 ;	 "	  "	 " (FLPTR)  <- FR0
FMOVE	=		 $DDB6		 ;FR1 <- FR0
PLYEVL  =		 $DD40		 ;FR0 <- P(Z) = SUM(I=N TO 0) (A(I)*Z**I) CAR
;									INPUT:  (X,Y) = A(N),A(N-1)...A(0) -> PLYARG
;											  ACC	= # OF COEFFICIENTS = DEGREE+1
;											  FR0	= Z
EXP	  =		 $DDC0		 ;FR0 <- E**FR0 = EXP10(FR0 * LOG10(E)) CARRY
EXP10	=		 $DDCC		 ;FR0 <- 10**FR0 CARRY
LOG	  =		 $DECD		 ;FR0 <- LN(FR0) = LOG10(FR0)/LOG10(E) CARRY
LOG10	=		 $DED1		 ;FR0 <- LOG10 (FR0) CARRY
; THE FOLLOWING ARE IN BASIC CARTRIDGE:
SIN	  =		 $BDB1		 ;FR0 <- SIN(FR0) DEGFLG=0 =>RADS, 6=>DEG. CA
COS	  =		 $BD73		 ;FR0 <- COS(FR0) CARRY
ATAN	 =		 $BE43		 ;FR0 <- ATAN(FR0) CARRY
SQR	  =		 $BEB1		 ;FR0 <- SQUAREROOT(FR0) CARRY
; FLOATING POINT ROUTINES ZERO PAGE (NEEDED ONLY IF V.P. ROUTINES ARE CA
		  *=$D4
FR0:	 .RES	 FPREC		 ;FP REG0
FRE:	 .RES	 FPREC
FR1:	 .RES	 FPREC		 ;FP REG1
FR2:	 .RES	 FPREC
FRX:	 .RES	 1			  ;FP SPARE
EEXP:	.RES	 1			  ;VALUE OF E
NSIGN:  .RES	 1			  ;SIGN OF #
ESIGN:  .RES	 1			  ;SIGN OF EXPONENT
FCHRFLG:.RES	 1			  ;1ST CHAR FLAG
DIORT:  .RES	 1			  ;# OF DIGITS RIGHT OF DECIMAL
CIX:	 .RES	 1			  ;CURRENT INPUT INDEX
INBUFF: .RES	 2			  ;POINTS TO USER'S LINE INPUT BUFFER
ZTEMPI: .RES	 2
ZIEMP4: .RES	 2
ZTEMP3: .RES	 2
DEGFLG
RADFLG: .RES	 1			  ;0=RADIANS, 6=DEGREES
RADON	=		 0			  ;INDICATES RADIANS
DEGON	=		 6			  ;INDICATES DEGREES
FLPTR:  .RES	 2			  ;POINTS TO USER'S FLOATING PT NUMBER
FPTR2:  .RES	 2
; FLOATING PT ROUTINES' NON-ZERO PAGE RAM
; (NEEDED ONLY IF F.P. ROUTINES CALLED)
		  *=$57E
LBPR1:  .RES	 1			  ;LBUFF PREFIX 1
LBPR2:  .RES	 1			  ;LBUFF PREFIX 2
LBUFF:  .RES	 128			;LINE BUFFER
PLYARG  =		 LBUFF+$60	;POLYNOMIAL ARGUMENTS
FPSCR	=		 PLYARG+FPREC
FPSCR1  =		 FPSCR+FPREC
FSCR	 =		 FPSCR
FSCR1	=		 FPSCR1
LBFEND  =		 *-1			;END OF LBUFF
;
;
;
;
;
;
;
;
;
;		 COLLEEN MNEMONICS
;
POKEY	=		 $D200		 ;VBLANK ACTION:			  DESCRIPTION:
POT0	 =		 POKEY+0	  ;POT0-->PADDL0			  0-227 IN RAM CELL
POT1	 =		 POKEY+1	  ;POT1-->PADDL1			  0-227 IN RAM CELL
POT2	 =		 POKEY+2	  ;POT2-->PADDL2			  0-227 IN RAM CELL
POT3	 =		 POKEY+3	  ;POT3-->PADDL3			  0-227 IN RAM CELL
POT4	 =		 POKEY+4	  ;POT4-->PADDL4			  0-227 IN RAM CELL
POT5	 =		 POKEY+5	  ;POT5-->PADDL5			  0-227 IN RAM CELL
POT6	 =		 POKEY+6	  ;POT6-->PADDL6			  0-227 IN RAM CELL
POT7	 =		 POKEY+7	  ;POT7-->PADDL7			  0-227 IN RAM CELL
ALLPOT  =		 POKEY+8	  ;???
KBCODE  =		 POKEY+9
RANDOM  =		 POKEY+10
POTGO	=		 POKEY+11	 ;STROBED
SERIN	=		 POKEY+13
IRQST	=		 POKEY+14
SKSTAT  =		 POKEY+15
AUDF1	=		 POKEY+0
AUDC1	=		 POKEY+1
AUDF2	=		 POKEY+2
AUDC2	=		 POKEY+3
AUDF3	=		 POKEY+4
AUDC3	=		 POKEY+5
AUDF4	=		 POKEY+6
AUDC4	=		 POKEY+7
AUDCTL  =		 POKEY+8	  ;NONE					 AUDCTL<--[SIO]
STIMER  =		 POKEY+9
SKRES	=		 POKEY+10	 ;NONE					  SKRES<--[SIO]
SEROUT  =		 POKEY+13	 ;NONE					 SEROUT<--[SIO]
IRQEN	=		 POKEY+14	 ;POKMSK-->IRQEN (AFFECTED BY OPEN S: OR E:)
SKCTL	=		 POKEY+15	 ;SSKCTL-->SKCTL		SSKCTL<--[SIO]
;
CTIA	 =		 $D000		 ;VBLANK ACTION:		 DESCRIPTION:
HPOSP0  =		 CTIA+0
HPOSP1  =		 CTIA+1
HPOSP2  =		 CTIA+2
HPOSP3  =		 CTIA+3
HPOSM0  =		 CTIA+4
HPOSM1  =		 CTIA+5
HPOSM2  =		 CTIA+6
HPOSM3  =		 CTIA+7
SIZEP0  =		 CTIA+8
SIZEP1  =		 CTIA+9
SIZEP2  =		 CTIA+10
SIZEP3  =		 CTIA+11
SIZEM	=		 CTIA+12
GRAFP0  =		 CTIA+13
GRAFP1  =		 CTIA+14
GRAFP2  =		 CTIA+15
GRAFP3  =		 CTIA+16
GRAFM	=		 CTIA+17
COLPM0  =		 CTIA+18	  ;PCOLR0-->COLPM0		WITH ATTRACT MODE
COLPM1  =		 CTIA+19	  ;PCOLR1-->COLPM1		WITH ATTRACT MODE
COLPM2  =		 CTIA+20	  ;PCOLR2-->COLPM2		WITH ATTRACT MODE
COLPM3  =		 CTIA+21	  ;PCOLR3-->COLPM3		WITH ATTRACT MODE
COLPF0  =		 CTIA+22	  ;COLOR0-->COLPF0		WITH ATTRACT MODE
COLPF1  =		 CTIA+23	  ;COLOR1-->COLPF1		WITH ATTRACT MODE
COLPF2  =		 CTIA+24	  ;COLOR2-->COLPF2		WITH ATTRACT MODE
COLPF3  =		 CTIA+25	  ;COLOR3-->COLPF3		WITH ATTRACT MODE
COLBK	=		 CTIA+26	  ;COLOR4-->COLBK		 WITH ATTRACT MODE
PRIOR	=		 CTIA+27	  ;(ON OPEN S: OR E:)	GPRIOR-->PRIOR
VDELAY  =		 CTIA+28
GRACTL  =		 CTIA+29
HITCLR  =		 CTIA+30
CONSOL  =		 CTIA+31	  ;$08-->CONSOL			TURN OFF SPEAKER
M0PF	 =		 CTIA+0
M1PF	 =		 CTIA+1
M2PF	 =		 CTIA+2
M3PF	 =		 CTIA+3
P0PF	 =		 CTIA+4
P1PF	 =		 CTIA+5
P2PF	 =		 CTIA+8
P3PF	 =		 CTIA+7
M0PL	 =		 CTIA+8
M1PL	 =		 CTIA+9
M2PL	 =		 CTIA+10
M3PL	 =		 CTIA+11
P0PL	 =		 CTIA+12
P1PL	 =		 CTIA+13
P2PL	 =		 CTIA+14
P3PL	 =		 CTIA+15
TRIG0	=		 CTIA+16	  ;TRIG0-->STRIG0
TRIG1	=		 CTIA+17	  ;TRIG1-->STRIG1
TRIG2	=		 CTIA+18	  ;TRIG2-->STRIG2
TRIG3	=		 CTIA+19	  ;TRIG3-->STRIG3
;
ANTIC	=		 $D400		 ;VBLANK ACTION		  DESCRIPTION
DMACTL  =		 ANTIC+0	  ;DMACTL<--SDMCTL		ON OPEN S: OR E:
CHACTL  =		 ANTIC+1	  ;CHACTL<--CHACT		 ON OPEN S: OR E:
DLISTL  =		 ANTIC+2	  ;DLISTL<--SDLSTL		ON OPEN S: OR E:
DLISTH  =		 ANTIC+3	  ;DLISTH<--SDLSTH		ON OPEN S: OR E:
NSCROL  =		 ANTIC+4
VSCROL  =		 ANTIC+5
PMBASE  =		 ANTIC+7
CHBASE  =		 ANTIC+9	  ;CHBASE<--CHBAS		 ON OPEN S: OR E:
WSYNC	=		 ANTIC+10
VCOUNT  =		 ANTIC+11
PENH	 =		 ANTIC+12
PENV	 =		 ANTIC+13
NMIEN	=		 ANTIC+14	 ;NMIEN<--40 POWER	  ON AND [SETVBV]
NMIRES  =		 ANTIC+15	 ;STROBED
NMIST	=		 ANTIC+15
PIA	  =		 $D300		 ;VBLANK ACTION		  DESCRIPTION
PORTA	=		 PIA+0		 ;PORTA-->STICK0,1	  X-Y CONTROLLERS
PORTB	=		 PIA+1		 ;PORTB-->STICK2,3	  X-Y CONTROLLERS
PACTL	=		 PIA+2		 ;NONE					  PACTL<--3C [INIT]
PBCTL	=		 PIA+3		 ;NONE					  PBCTL<--3C [INIT]
;
;
;
; .PAGE
		  .PAGE
		  LIST	 S
		  .TITLE  'CENTRAL INPUT/OUTPUT (CIO) 2-7-79'
;					UPDATED BY AL MILLER 3-9-79
ASCZER  =		 '0			 ;ASCII ZERO
COLON	=		 $3A			;ASCII COLON
EOL	  =		 $9B			;END OF RECORD
		  .PAGE
;
; CIO JUMP VECTOR FOR USERS
		  *=CIOV
		  JMP	  CIO			;GO TO CIO
;
; CIO INIT JUMP VECTOR FOR POWER UP
		  *=CIOINV
		  JMP	  CIOINT		;GO TO INIT
;
;
; ERROR ROUTINE ADDRESS EQUATE
; ERRTNH =ERRTN/256			"MOVED TO LINE 788"
; ERRTNL =-ERRTNH*256+ERRTN "MOVED TO LINE 789"
;
;
		  *=CIOORG
;
; CIO INITIALIZATION (CALLED BY MONITOR AT POWER UP)
CIOINT: LDX	  #0
CIOI1:  LDA	  #IOCFRE	  ;SET ALL IOCB'S TO FREE
		  STA	  ICHID,X	  ;BY SETTING HANDLER ID'S=$FF
		  LDA	  #ERRTNL
		  STA	  ICPTL,X	  ;POINT PUT TO ERROR ROUTINE
		  LDA	  #ERRTNH
		  STA	  ICPTH,X
		  TXA
		  CLC
		  ADC	  #IOCBSZ	  ;BUMP INDEX BY SIZE
		  TAX
		  CMP	  #MAXIOC	  ;DONE?
		  BCC	  CIOI1		 ;NO
		  RTS					  ;YES, RETURN
;
; ERROR ROUTINE FOR ILLEGAL PUT
ERRTN	=*-1
ERRTNH  =ERRTN/256
ERRTNL  =(-ERRTNH)*256+ERRTN
		  LDY	  #NOTOPN	  ;IOCB NOT OPEN
		  RTS
		  .PAGE
;
; CIO LOCAL RAM (USES SPARE BYTES IN ZERO PAGE IOCB)
ENTVEC  =		 ICSPRZ
;
; CIO MAIN ROUTINE
;
; CIO INTERFACES BETWEEN USER AND INPUT/OUTPUT DE
CIO:	 STA	  CIOCHR		;SAVE POSSIBLE OUTPUT CHARACTER
		  STX	  ICIDNO		;SAVE IOCB NUMBER * N
;
; CHECK FOR LEGAL IOCB
		  TXA
		  AND	  #$F			;IS IOCB MULTIPLE OF 16?
		  BNE	  CIERR1		;NO, ERROR
		  CPX	  #MAXIOC	  ;IS INDEX TOO LARGE?
		  BCC	  IOC1		  ;NO
;
; INVALID IOCB NUMBER -- RETURN ERROR
CIERR1: LDY	  #BADIOC	  ;ERROR CODE
		  JMP	  CIRTN1		;RETURN
;
; MOVE USER IOCB TO ZERO PAGE
IOC1:	LDY	  #0
IOC1A:  LDA	  IOCB,X		;USER IOCB
		  STA	  IOCBAS,Y	 ;TO ZERO PAGE
		  INX
		  INY
		  CPY	  #12			;12 BYTES
		  BCC	  IOC1A
;
; COMPUTE CIO INTERNAL VECTOR FOR COMMAND
		  LDY	  #NVALID	  ;ASSUME INVALID CODE
		  LDA	  ICCOMZ		;COMMAND CODE TO INDEX
		  CMP	  #OPEN		 ;IS COMMAND LEGAL?
		  BCC	  CIERR4		;NO
		  TAY
;
; MOVE COMMAND TO ZERO BASE FOR INDEX
		  CPY	  #SPECIL	  ;IS COMMAND SPECIAL?
		  BCC	  IOC2		  ;NO
		  LDY	  #SPECIL	  ;YES, SET SPECIAL OFFSET INDEX
IOC2:	STY	  ICCOMT		;SAVE COMMAND FOR VECTOR
		  LDA	  COMTAB-3,Y  ;GET VECTOR OFFSET FROM TABLE
		  BEQ	  CIOPEN		;GO IF OPEN COMMAND
		  CMP	  #2			 ;IS IT CLOSE?
		  BEQ	  CICLOS		;YES
		  CMP	  #8			 ;IS IT STATUS OR SPECIAL?
		  BCS	  CISTSP		;YES
		  CMP	  #4			 ;IS IT READ?
		  BEQ	  CIREAD		;YES
		  JMP	  CIWRIT		;ELSE, MUST BE WRITE
		  .PAGE
;
; OPEN COMMAND
;
; FIND DEVICE HANDLER IN HANDLER ADDRESS TABLE
CIOPEN: LDA	  ICHIDZ		;GET HANDLER ID
		  CMP	  #IOCFRE	  ;IS THIS IOCB CLOSED?
		  BEQ	  IOC6		  ;YES
;
; ERROR -- IOCB ALREADY OPEN
CIERR3: LDY	  #PRVOPN	  ;ERROR CODE
CIERR4: JMP	  CIRTN1		;RETURN
;
; GO FIND DEVICE
IOC6:	JSR	  DEVSRC		;CALL DEVICE SEARCH
		  BCS	  CIERR4		;GO IF DEVICE NOT FOUND
;
; DEVICE FOUND, INITIALIZE IOCB FOR OPEN
;
; COMPUTE HANDLER ENTRY POINT
IOC7:	JSR	  COMENT
		  BCS	  CIERR4		;GO IF ERROR IN COMPUTE
;
; GO TO HANDLER FOR INITIALIZATION
		  JSR	  GOHAND		;USE INDIRECT JUMP
;
; STORE PUT BYTE ADDRESS-1 INTO IOCB
		  LDA	  #PUTCHR	  ;SIMULATE PUT CHARACTER
		  STA	  ICCOMT
		  JSR	  COMENT		;COMPUTE ENTRY POINT
		  LDA	  ICSPRZ		;MOVE COMPUTED VALUE
		  STA	  ICPTLZ		;TO PUT BYTE ADDRESS
		  LDA	  ICSPRZ+1
		  STA	  ICPTHZ
		  JMP	  CIRTN2		;RETURN TO USER
		  .PAGE
;
;
; CLOSE COMMAND
CICLOS: LDY	  #SUCCES	  ;ASSUME GOOD CLOSE
		  STY	  ICSTAZ
		  JSR	  COMENT		;COMPUTE HANDLER ENTRY POINT
		  BCS	  CICLO2		;GO IF ERROR IN COMPUTE
		  JSR	  GOHAND		;GO TO HANDLER TO CLOSE DEVICE
CICLO2: LDA	  #IOCFRE	  ;GET IOCB "FREE" VALUE
		  STA	  ICHIDZ		;SET HANDLER ID
		  LDA	  #ERRTNH
		  STA	  ICPTHZ		;SET PUT BYTE TO POINT TO ERROR
		  LDA	  #ERRTNL
		  STA	  ICPTLZ
		  JMP	  CIRTN2		;RETURN
;
;
; STATUS AND SPECIAL REQUESTS
; DO IMPLIED OPEN IF NECESSARY AND GO TO DEVICE
CISTSP: LDA	  ICHIDZ		;IS THERE A HANDLER ID?
		  CMP	  #IOCFRE
		  BNE	  CIST1		 ;YES
;
; IOCB IS FREE, DO IMPLIED OPEN
		  JSR	  DEVSRC		;FIND DEVICE IN TABLE
		  BCS	  CIERR4		;GO IF ERROR IN COMPUTE
;
; COMPUTE AND GO TO ENTRY POINT IN HANDLER
CIST1:  JSR	  COMENT		;COMPUTER HANDLER ENTRY VECTOR
		  JSR	  GOHAND		;GO TO HANDLER
;
; RESTORE HANDLER INDEX (DO IMPLIED CLOSE)
		  LDX	  ICIDNO		;IOCB INDEX
		  LDA	  ICHID,X	  ;GET ORIGINAL HANDLER ID
		  STA	  ICHIDZ		;RESTORE ZERO PAGE
		  JMP	  CIRTN2		;RETURN
		  .PAGE
;
; READ -- DO GET COMMANDS
CIREAD: LDA	  ICCOMZ		;GET COMMAND BYTE
		  AND	  ICAX1Z		;IS THIS READ LEGAL?
		  BNE	  RCI1A		 ;YES
;
; ILLEGAL READ -- IOCB OPENED FOR WRITE ONLY
		  LDY	  #WRONLY	  ;ERROR CODE
RCI1B:  JMP	  CIRTN1		;RETURN
;
; COMPUTE AND CHECK ENTRY POINT
RCI1A:  JSR	  COMENT		;COMPUTE ENTRY POINT
		  BCS	  RCI1B		 ;GO IF ERROR IN COMPUTE
;
; GET RECORD OR CHARACTERS
		  LDA	  ICBLLZ
		  ORA	  ICBLLZ+1	 ;IS BUFFER LENGTH ZERO?
		  BNE	  RCI3		  ;NO
		  JSR	  GOHAND
		  STA	  CIOCHR
		  JMP	  CIRTN2
;
; LOOP TO FILL BUFFER OR END RECORD
RCI3:	JSR	  GOHAND		;GO TO HANDLER TO GET BYTE
		  STA	  CIOCHR		;SAVE BYTE
		  BMI	  RCI4		  ;END TRANSFER IF ERROR
		  LDY	  #0
		  STA	  (ICBALZ),Y  ;PUT BYTE IN USER BUFFER
		  JSR	  INCBFP		;INCREMENT BUFFER POINTER
		  LDA	  ICCOMZ		;GET COMMAND CODE
		  AND	  #2			 ;IS IT GET RECORD?
		  BNE	  RCI1		  ;NO
;
; CHECK FOR EOL ON TEXT RECORDS
		  LDA	  CIOCHR		;GET BYTE
		  CMP	  #EOL		  ;IS IT AN EOL?
		  BNE	  RCI1		  ;NO
		  JSR	  DECBFL		;YES, DECREMENT BUFFER LENGTH
		  JMP	  RCI4		  ;END TRANSFER
;
; CHECK BUFFER FULL
RCI1:	JSR	  DECBFL		;DECREMENT BUFFER LENGTH
		  BNE	  RCI3		  ;CONTINUE IF NON ZERO
		  .PAGE
;
; BUFFER FULL. RECORD NOT ENDED
; DISCARD BYTES UNTIL END OF RECORD
RCI2:	LDA	  ICCOMZ		;GET COMMAND BYTE
		  AND	  #2			 ;IS IT GET CHARACTER?
		  BNE	  RCI4		  ;YES, END TRANSFER
;
; LOOP TO WAIT FOR EOL
RCI6:	JSR	  GOHAND		;GET BYTE FROM HANDLER
		  STA	  CIOCHR		;SAVE CHARACtER
		  BMI	  RCI4		  ;GO IF ERROR
;
; TEXT RECORD. WAIT FOR EOL
		  LDA	  CIOCHR		;GET GOT BYTE
		  CMP	  #EOL		  ;IS IT EOL?
		  BNE	  RCI6		  ;NO, CONTINUE
;
; END OF RECORD. BUFFER FULL -- SEND TRUNCATED RECORD MESSAGE
RCI1I:  LDA	  #TRNRCD	  ;ERROR CODE
		  STA	  ICSTAZ		;STORE IN 10GB
;
; TRANSFER DONE
RCI4:	JSR	  SUBBFL		;SET FINAL BUFFER LENGTH
		  JMP	  CIRTN2		;RETURN
		  .PAGE
;
; WRITE -- DO PUT COMMANDS
CIWRIT: LDA	  ICCOMZ		;GET COMMAND BYTE
		  AND	  ICAX1Z		;IS THIS WRITE LEGAL?
		  BNE	  WCIIA		 ;YES
;
; ILLEGAL WRITE -- DEVICE OPENED FOR READ ONLY
		  LDY	  #RDONLY	  ;ERROR CODE
WCI1B:  JMP	  CIRTN1		;RETURN
;
;  COMPUTE AND CHECK ENTRY POINT
WCIIA:  JSR	  COMENT		;COMPUTE HANDLER ENTRY POINT
		  BCS	  WCI1B		 ;GO IF ERROR IN COMPUTE
;
; PUT RECORD OR CHARACTERS
		  LDA	  ICBLLZ
		  ORA	  ICBLLZ+1	 ;IS BUFFER LENGTH ZERO?
		  BNE	  WCI3		  ;NO
		  LDA	  CIOCHR		;GET CHARACTER
		  INC	  ICBLLZ		;SET SUFFER LENOTHI
		  BNE	  WCI4		  ;THEN JUST TRANSFER ONE BYTE
;
; LOOP TO TRANSFER BYTES FROM BUFFER TO HANDLER
WCI3:	LDY	  #0
		  LDA	  (ICBALZ),Y  ;GET BYTE FROM BUFFER
		  STA	  CIOCHR		;SAVE
WCI4:	JSR	  GOHAND		;GO PUT BYTE
		  BMI	  WCI5		  ;END IF ERROR
		  JSR	  INCBFP		;INCREMENT BUFFER POINTER
;
; CHECK FOR TEXT RECORD
		  LDA	  ICCOMZ		;GET COMMAND BYTE
		  AND	  #2			 ;IS IT PUT RECORD?
		  BNE	  WCI1		  ;NO
;
; TEXT RECORD -- CHECK FOR EOL TRANSFER
		  LDA	  CIOCHR		;GET LAST CHARACTER
		  CMP	  #EOL		  ;IS IT AN EOL?
		  BNE	  WCI1		  ;NO
		  JSR	  DECBFL		;DECREMENT BUFFER LENGTH
		  JMP	  WCI5		  ;END TRANSFER
;
; CHECK FOR BUFFER EMPTY
WCI1:	JSR	  DECBFL		;DECREMENT BUFFER LENGTH
		  BNE	  WCI3		  ;CONTINUE IF NON ZERO
		  .PAGE
;
; BUFFER EMPTY, RECORD NOT FILLED
; CHECK TYPE OF TRANSFER
WCI2:	LDA	  ICCOMZ		;GET COMMAND CODE
		  AND	  #2			 ;IS IT PUT CHARACTER?
		  BNE	  WCI5		  ;YES, END TRANSFER
;
; PUT RECORD (TEXT), BUFFER ,EMPTY, SEND EOL
		  LDA	  #EOL
		  JSR	  GOHAND		;GO TO HANDLER
;
; END PUT TRANSFER
WCI5:	JSR	  SUBBFL		;SET ACTUAL PUT BUFFER LENGTH
		  JMP	  CIRTN2		;RETURN
		  .PAGE
;
; CIO RETURNS
; RETURNS WITH Y=STATUS
CIRTN1: STY	  ICSTAZ		;SAVE STATUS
;
; RETURNS WITH STATUS STORED IN ICSTAZ
; MOVE IOCB IN ZERO PAGE BACK TO USER AREA
CIRTN2: LDY	  ICIDNO		;GET IOCB INDEX
		  LDA	  ICBAL,Y
		  STA	  ICBALZ		;RESTORE USER BUFFER POINTER
		  LDA	  ICBAH,Y
		  STA	  ICBAHZ
		  LDX	  #0			 ;LOOP COUNT AND INDEX
CIRT3:  LDA	  IOCBAS,X	 ;ZERO PAGE
		  STA	  IOCB,Y		;TO USER AREA
		  INX
		  INY
		  CPX	  #12			;12 BYTES
		  BCC	  CIRT3
;
; RESTORE A,X, & Y
		  LDA	  CIOCHR		;GET LAST CHARACTER
		  LDX	  ICIDNO		;IOCB INDEX
		  LDY	  ICSTAZ		;GET STATUS AND SET FLAGS
		  RTS					  ;RETURN TO USER
		  .PAGE
;
;
; CIO SUBROUTINES
;
; COMENT -- CHECK AND COMPUTE HANDLER ENTRY POINT
COMENT: LDY	  ICHIDZ		;GET HANDLER INDEX
		  CPY	  #MAXDEV+1	;IS IT A LEGAL INDEX?
		  BCC	  COM1		  ;YES
;
; ILLEGAL HANDLER INDEX MEANS DEVICE NOT OPEN FOR OPERATION
		  LDY	  #NOTOPN	  ;ERROR CODE
		  BCS	  COM2		  ;RETURN
;
; USE HANDLER ADDRESS TABLE AND COMMAND TABLE TO GET VECTOR
COM1:	LDA	  HATABS+1,Y  ;GET LOW BYTE OF ADDRESS
		  STA	  ICSPRZ		;AND SAVE IN POINTER
		  LDA	  HATABS+2,Y  ;GET HI BYTE OF ADDRESS
		  STA	  ICSPRZ+1
		  LDY	  ICCOMT		;GET COMMAND CODE
		  LDA	  COMTAB-3,Y  ;GET COMMAND OFFSET
		  TAY
		  LDA	  (ICSPRZ),Y  ;GET LOW BYTE OF VECTOR FROM
		  TAX					  ;HANDLER ITSELF AND SAVE
		  INY
		  LDA	  (ICSPRZ),Y  ;GET HI BYTE OF VECTOR
		  STA	  ICSPRZ+1
		  STX	  ICSPRZ		;SET LO BYTE
		  CLC					  ;SHOW NO ERROR
COM2:	RTS
;
;
; DECBFL -- DECREMENT BUFFER LENGTH DOUBLE BYTE
; Z FLAG = 0 ON RETURN IF LENGTH = 0 AFTER DECREMENT
DECBFL: DEC	  ICBLLZ		;DECREMENT LOW BYTE
		  LDA	  ICBLLZ		;CHECK IT
		  CMP	  #$FF		  ;DID IT GO BELOW?
		  BNE	  DECBF1		;NO
		  DEC	  ICBLLZ+1	 ;DECREMENT HI BYTE
DECBF1: ORA	  ICBLLZ+1	 ;SET Z IF BOTH ARE ZERO
		  RTS
;
;
; INCBFP -- INCREMENT WORKING BUFFER POINTER
INCBFP: INC	  ICBALZ		;BUMP LOW BYTE
		  BNE	  INCBF1		;GO IF NOT ZERO
		  INC	  ICBALZ+1	 ;ELSE, BUMP HI BYTE
INCBF1: RTS
;
;
; SUBBFL -- SET BUFFER LENGTH = BUFFER LENGTH - WORKING BYTE COUNT
SUBBFL: LDX	  ICIDNO		;GET IOCB INDEX
		  SEC
		  LDA	  ICBLL,X	  ;GET LOW BYTE OF INITIAL LENGTH
		  SBC	  ICBLLZ		 ;SUBTRACT FINAL LOW BYTE
		  STA	  ICBLLZ		;AND SAVE BACK
		  LDA	  ICBLH,X	  ;GET HI BYTE
		  SBC	  ICBLLZ+1
		  STA	  ICBLHZ
		  RTS
;
;
; GOHAND -- GO INDIRECT TO A DEVICE HANDLER
; Y= STATUS ON RETURN, N FLAG=1 IF ERROR ON RETURN
GOHAND: LDY	  #FNCNOT	  ;PREPARE NO FUNCTION STATUS FOR HANDLER RTS
		  JSR	  CIJUMP		;USE THE INDIRECT JUMP
		  STY	  ICSTAZ		;SAVE STATUS
		  CPY	  #0			 ;AND SET N FLAG
		  RTS
;
; INDIRECT JUMP TO HANDLER BY PAUL'S METHOD
CIJUMP: TAX					  ;SAVE A
		  LDA	  ICSPRZ+1	 ;GET JUMP ADDRESS HI BYTE
		  PHA					  ;PUT ON STACK
		  LDA	  ICSPRZ		;GET JUMP ADDRESS LO BYTE
		  PHA					  ;PUT ON STACK
		  TXA					  ;RESTORE A
		  LDX	  ICIDNO		;GET IOCB INDEX
		  RTS					  ;GO TO HANDLER INDIRECTLY
		  .PAGE
;
; DEVSRC -- DEVICE SEARCH, FIND DEVICE IN HANDLER ADDRESS TABLE
;
; LOOP TO FIND DEVICE
DEVSRC: LDY	  #0
		  LDA	  (ICBALZ),Y  ;GET DEVICE NAME FROM USER
		  BEQ	  CIERR2
		  LDY	  #MAXDEV	  ;INITIAL COMPARE INDEX
DEVS1:  CMP	  HATABS,Y	 ;IS THIS THE DEVICE?
		  BEQ	  DEVS2		 ;YES
		  DEY
		  DEY					  ;ELSE, POINT TO NEXT DEVICE NAME
		  DEY
		  BPL	  DEVS1		 ;CONTINUE FOR ALL DEVICES
;
; NO DEVICE FOUND, DECLARE NON-EXISTENT DEVICE ERROR
CIERR2: LDY	  #NONDEV	  ;ERROR CODE
		  SEC					  ;SHOW ERROR
		  BCS	  DEVS4		 ;AND RETURN
;
; FOUND DEVICE, SET ICHID,ICDNO, AND INIT DEVICE
DEVS2:  TYA
		  STA	  ICHIDZ		;SAVE HANDLER INDEX
		  SEC
		  LDY	  #1
		  LDA	  (ICBALZ),Y  ;GET DEVICE NUMBER (DRIVE NUMBER)
		  SBC	  #ASCZER	  ;SUBTRACT ASCII ZERO
		  CMP	  #$A			;IS NUMBER IN RANGE?
		  BCC	  DEVS3		 ;YES
		  LDA	  #1			 ;NO. DEFAULT TO ONE
DEVS3:  STA	  ICDNOZ		;SAVE DEVICE NUMBER
		  CLC					  ;SHOW NO ERROR
;
; RETURN
DEVS4:  RTS
		  .PAGE
;
;
; CIO ROM TABLES
;
; COMMAND TABLE
; MAPS EACH COMMAND TO OFFSET FOR APPROPRIATE VECTOR IN HANDLER
COMTAB: BYTE	 0,4,4,4,4,6,6,6,6,2,8,10


LENGTH  =*-CIOINT
CRNTP1  =*
		  *=$14
CIOSPR: BYTE	 INTORG-CRNTP1 ;^GCIOL IS TOO LONG
;
		  .TITLE  'INTERRUPT HANDLER'
;LIVES ON DK1:INTHV.SRC
SRTIM2  =		 6			  ;SECOND REPEAT INTERVAL
;
; THIS IS TO MAKE DOS 2 WORK WHICH USED AN ABSOLUTE ADDRESS
;
		  *=$E912
		  JMP	  SETVBL
		  *=SETVBV
		  JMP	  SETVBL
		  JMP	  SYSVBL
		  JMP	  XITVBL
		  *=INTINV
		  JMP	  IHINIT
;
		  *=VCTABL+INTABS-VDSLST
;
		  .WORD	SYRTI		 ;VDSLST
		  .WORD	SYIRQB		;VPRCED
		  .WORD	SYIRQB		;VINTER
		  .WORD	SYIRQB		;VBREAK
;
		  .RES	 8
		  .WORD	SYIRQB		;VTMIR1
		  .WORD	SYIRQB		;VTIMR2
		  .WORD	SYIRQB		;VTMIR4
		  .WORD	SYIRQ		 ;VIMIRQ
		  .WORD	0,0,0,0,0	;CDTMV1-4
